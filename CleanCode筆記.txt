Clean Code:
專注，每個function, class, module都能表達單一意圖，不受周邊細節干擾與汙染
簡單明瞭

當同樣的事情一做再做，代表我們的想法沒有很好的表達在程式中

Ch2 有意義的命名
使名稱代表其意圖
透過修改變數的名稱，僅看程式可以了解意義

避免誤導:
避開使用和原意圖違背的常見單字
hp, seo, list等
也避免讓變數名稱太相近

產生有意義的區別
有些相近命名無法了解真實的意圖
例如:Product, ProductData, ProductInfo

字首:
變數前加入m_的方式現今很少採用，一般人會忽略m_直接閱讀後面的單字

類別的命名:
應使用名詞，例如Customer, Wikipage，避免使用Manager, Processor, Data. Info之類

方法的命名"
應用動詞，根據javabean標準，取出應用get當字首，修改用set，判定用is

每個概念使用一種字詞:
例如controller, manager, driver
DeviceManager和ProtocolController，可以都用controller或用manager

Ch3 函式
-簡短
應該簡短到可以一眼就看出本身的意圖（3~4行）
-區塊與縮排
If else while及其他敘述應只有一行，函式也不應該大到包含巢狀結構，因此縮排一般不應大過於兩層

綜上所述，函式應該做一件事。它們應該把這件事做好。而且它們也應該只做這件事

見Listing 3-1~3
如果函式可以被拆解成幾個段落，這是做超過一件事的明顯徵兆

-每個函式只有一層抽象概念
程式的閱讀可以像由上而下的敘事，每個函式後面都緊接著下一個層次的抽象概念
這方法可稱為降層準則
函式能做某些事，能回答某些問題，但不應該同時出現（指令與查詢分離）

-Swich
這個敘述很難完成上述的原則，如果存在一定要使用的情況，應可以和抽象/介面合併使用

-函式的參數
參數越少越理想，避免超過三個
參數處與和函式不同的抽象層級，且會強迫閱讀者去瞭解目前並不那麼重要的細節
傳遞相同概念的參數時，可以建立物件

-Boolean
將布林值傳遞給函式是個不太好的做法，這等於函式要做兩件事情

-使用例外處理取代錯誤回傳碼
常見指令函式處理完後回傳處理結果，再依據處理結果進行後續處理

作者認為這樣的方式不好？

另try/catch的區塊會混淆程式本身的結構，應提取出來，將try/ctach與執行端分離
錯誤處理本身可就可以當作是一件事

-結構化程式設計
每個函式卻及其區塊，應都只有一個進入點與離開點
換句話說，每個函式只能有一個return，迴圈內不能有break及continue

-結論
寫函式和寫文章一樣，初稿總是粗糙且雜亂無章，寫完後要多次修改，將文章改善至想要的樣子

Ch4 註解
最好的辦法是可以透過程式碼本身來瞭解程式，而用不到註解
與其花時間寫註解，不如去整理程式碼

-闡明
對函式庫或某些不能修改的程式碼，可以加入一段幫助敘述的註解
當可以使用函式或變數時就別用註解

-大括號後面的註解
某些時候在}後面會存在註解來說明
如果有必要在後面留下註解，那不如試著簡短函式

Ch5編排
程式碼的風格與可讀性，將會持續影響程式的可維護性與可擴充性

—垂直的編排
-垂直間隔與密度
概念間應用垂直空白
如果是相關的．應緊密在一起

-垂直距離
相似的概念應盡可能靠近，使用者不用想辦法尋找相關的東西在哪

變數宣告（Variable Declaations）：
應盡可能靠近變數被使用的地方，若函式比較簡短，可在最上方宣告

實體變數（Instance variables）：
應在該類別的最上方

相依的函式（Dependent Functions）：
呼叫敘述應在被呼叫敘述的上方

概念相似性（Conceptual Affinity）：
其之間的垂直距離應越短越好

總之，我們希望可以由上而下閱讀到重點

-水平的編排
運算子例如+=的兩側可以加入空白來強調
a - b - (2*a); 乘法因子沒有空白，表示擁有較高的優先權

-縮排
應將程式維持原有的結構，避免塌陷成一行

根據這個原則， ？ ：的結構也要少用

Ch6 物件及資料結構
以讀卡機或接第三方遊戲為例，抽象與隱藏資料的做法可以很簡單的達成替換的目的

-德摩特爾法則(The Law of Demeter)：
方法不該呼叫"任何由函式所回傳之物件"的方法
例如：
final String outputDir = ctxt.getOptions().getscratchDir().getAbsolutePath();

但這似乎是新語言的特徵？

Ch7錯誤處理
錯誤處理很重要，但如果它模糊了原本程式碼的邏輯，那就有問題了

將try/catch拆出來處理是個比較好的方法


-包裹類別的處理方法
參考p121的方法，JS應該也適用
這做法有點類似抽象化，即使替換第三方API，原有的程式也無須修改

不要回傳NULL，也不要傳遞 NULL

Ch8 外來與本地程式碼的邊界
可以使用封裝的方式將第三方程式碼的形態與方法包裝起來再使用

-學習式測試
將第三方軟體整合前，可以另行開發一支測試軟體
其測試重點是我們想從第三方軟體獲得什麼成果

當第三方軟體有改版，一樣可以先透過這支程式來瞭解執行狀況是否符合預期
這可以大幅減輕升級的負擔

Ch9 單元測試
-TDD三大原則
1.在撰寫一個可以測試失敗的單元測試前，不可撰寫任何產品程式
2.只撰寫剛好無法通過測試的單元測試，不能編譯也算無法通過測試
3.只撰寫剛好能通過當前測試失敗的程式產品

-好的測試
一次測試一個斷言
一次測試一個概念

-F.I.R.S.T
Fast(快速)
Independent(獨立)
測試程式不應該互相依賴
Repeatable(可重複性)
可在任何情況下重複執行
Self-Validating(自我驗證)
測試程式應主動輸出boolean
Timely(及時)
單元測試最好在產品程式開發之前不久先進行開發

Ch10 類別
-類別結構
公用靜態常數
私有靜態常數
私有實體變數
公用函式
私有工具函式

-簡短
遵循[函式]的概念，類別也應簡短

-單一職責原則
一個類別或模組應只能有一個[修改的理由]
例如:修改版本資訊可以為一個單獨的類別

[讓軟體能夠運作]和[讓軟體保持整潔]是兩件不同的事情
一次專注於其中一件是沒問題的，但能順利運作後，要記得回來重新整理

有些開發者擔心，大量小型,單一目標的類別會讓程式的全貌難以理解
這個問題等於：你想將工具有組織地放在有許多良好定義和良好標記元件的小抽屜，還是只想要少量大抽屜可以將所以東西丟進去

-凝聚力
類別的每個方法都應操作一個或多個類別內的變數
若有類別的每個變數都被使用在每個方法內，則該類別即具有最大凝聚性

保持凝聚力，也可很好的保持單一職責原則

Ch11 系統

-你如何建造一個城市
某些人負責城市的整體規劃，其他人則專注在細節的執行
城市已經有適當的抽象化層次和模組化，就算不了解細節是甚麼，[元件]也能有效地運行

-劃分系統的建造和使用
應將物件建構的[起始]和[連結]過程和正常執行邏輯分離，將之模組化，確保有整體一致的策略

方式:
1.將建造的方法移置Main
2.抽出建造的方法到一個新的[工廠]
3.相依性注入

Ch12 羽化
簡單設計四守則
1.執行完所有的測試
2.沒有重複的部分
3.表達設計師的本意
4.最小化類別和方法的數量